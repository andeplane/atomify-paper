\documentclass[aps,pre,twocolumn,letterpaper,floatfix,nofootinbib]{revtex4}
	% for \code color
\usepackage[dvipsnames]{xcolor}
\usepackage{graphicx} 
\usepackage{amsmath,amssymb,amsfonts} 
\usepackage{mathtools}
\usepackage{pdfpages}
\usepackage{afterpage}
\usepackage[hidelinks]{hyperref} 
\usepackage{epstopdf}
\usepackage{todo}
\usepackage{menukeys}
\usepackage{siunitx}
\usepackage{listings}
% Pretty formating of c++ (see \cpp command)
\usepackage{xspace}
\newcommand*{\cpp}{C\ensuremath{++}\xspace}

\lstdefinelanguage{LAMMPS}{
    morekeywords={units,atom_style,lattice,region,create_box,create_atoms,pair_style,pair_coeff,neigh_modify,mass,velocity,fix,run},
    sensitive=false, % keywords are not case-sensitive
    morecomment=[l]{//}, % l is for line comment
    morecomment=[s]{/*}{*/}, % s is for start and end delimiter
    morestring=[b]" % defines that strings are enclosed in double quotes
}

\lstset{
numbers=left, 
numberstyle=\small, 
numbersep=8pt, 
frame = single, 
language=LAMMPS, 
framexleftmargin=15pt,
xleftmargin=0.65cm,
xrightmargin=0.1cm}

% Highlighte inline code
\definecolor{light-gray}{gray}{0.95}
\definecolor{atomify-red}{rgb}{0.90196078 , 0.09803922, 0.29411765}
\definecolor{atomify-green}{rgb}{0.23529412 , 0.70588235, 0.29411765}
\definecolor{atomify-yellow}{rgb}{0.8,  0.70588235,  0.07843138}
\definecolor{atomify-blue}{rgb}{0.00000000 , 0.50980392, 0.78431373}
%\newcommand{\code}[1]{\mbox {\texttt{#1}}}
\newcommand{\code}[1]{\colorbox{light-gray}{\color{RawSienna}\texttt{#1}}}

\begin{document}

\title{Increased productivity using Atomify - a real-time LAMMPS visualizer}
\author{Anders Hafreager$^1$}
\author{Svenn-Arne Dragly$^{1}$} 
\author{Anders Malthe-S\o renssen$^1$}
\affiliation{$^1$Department of Physics - University of Oslo\\Sem S{\ae}lands vei 24, NO-0316, Oslo, Norway }
\date{\today} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{abstract}
%
The typical workflow when running atomistic simulations includes working with several programs.
A text editor is needed to create and modify the scripts, the terminal to run the simulation, and programs like VMD or Ovito to visualize the system over time.
If physical quantities are computed, the data is often plotted with MATLAB or Python, where additional scripts must be used.
This is a tedious process, especially for teaching purposes and for people who are new in the field.
We here introduce Atomify; a high performance real-time visualizer for atomistic simulations that can simulate and render more than one million atoms with excellent frame rate on modern hardware.
Atomify supports OpenMP acceleration, GPU acceleration, real-time plotting of physical quantities, and an easy-to-use code editor in one single application.
It currently uses LAMMPS as physics engine, but it can be extended to support other codes like Gromacs, NAMD or OpenMM.
Atomify is open-source software (GPL) written in C++ using the Qt framework.
%
\end{abstract} 
 
\maketitle

\section{Introduction}
Our nature is a very complex system with complicated rules that determine how, and where mass, energy and momentum is transferred.
Many macroscopic observable effects result from microscopic details on the atomic level such as melting of ice, and even life.
Understanding the world from a bottom-up perspective requires us to be able to model a physical system from the atomic scale where the timescale is of order femtoseconds.
Many physical and chemical processes happen on nanosecond timescales, some even during a few picoseconds, which means thousands or millions of timesteps of \SI{1}{\femto\second} need to be calculated.
Much has happened since the first molecular dynamics simulation of hard spheres in the 1950s\citep{alder1957phase,alder1959studies}, and later, in 1964, a more realistic system with the Lennard Jones potential studying diffusion in argon\citep{rahman1964correlations}.
The computing power has seen a tremendous increase from the CDC 3600 used in \citep{rahman1964correlations}, which performed less than 1 million instructions per second whereas modern 3 Ghz processors in typical laptops can do about 100 billion instructions per seconds.
With this rapidly increase of computing power, the lengthscales and timescales achievable in numeriments\footnote{Numeriment is a numerical experiment, or a simulation on the computer.} is finally catching up with some experiments (ref).

In molecular dynamics, a set of atoms is integrated using Newton's second law in a classical force field so the full phase space is known at all times and statistical properties can be calculated from averages assuming ergodicity.
It has been prooved successful in reproducing and explaining multiple phenomenon such as mechanical properties \citep{jiang2009young, campbell1999structural, ning2012mechanical}, chemical reactions \citep{van2001reaxff, brenner2002second}, liquid properties\citep{allen2017computer}.
Also in biology, molecular dynamics is useful blabla.

Over the years, increasingly sophisticated methods have been developed.
For instance, a non-equilibrium method to measure thermal conductivity using heat exchange, was recently improved\citep{wirnsberger2015enhanced} to conserve energy better.
To study first order phase transitions, methods like the generalized replica exchange method (gREM)\citep{kim2010generalized} can be used and nudge elastic band (NEB)\citep{henkelman2000climbing, henkelman2000improved} is often used to study energy barriers in for instance chemical reactions.
In addition, a huge amount of force fields exists, each being good at different things.
New hardware and a sea of optimization tricks makes implementing a good molecular dynamics code a challenging task, not to mention maintaining it over time on new arcitechtures.
Each new feature or technique like the ones metioned above, may take days, if not weeks, to develop, preventing researchers to work on their scientific projects.

Thanksfully, there already exists several software packages for atomistic simulations, many of which have been developed for more than two decades\footnote{\url{https://en.wikipedia.org/wiki/Comparison_of_software_for_molecular_mechanics_modeling} compares different softwares for molecular modeling.}.
Some of these packages, such as LAMMPS\citep{Plimpton1995Fast}, Gromacs\citep{berendsen1995gromacs}, NAMD\citep{Phillips2005Scalable} and CHARMM\citep{brooks2009charmm}, are open source and being actively developed with hundreds of contributers.
%After the rise of powerful graphical processing units (GPU's), most of these codes eventually added support of using accelerators\citep{brown2011implementing}.

\lstinputlisting[language=LAMMPS,caption={A minimal LAMMPS input script that simulates a Lennard Jones solid at reduced temperature $T^* = 1.0$ with a reduced density of $\rho^* = 0.8442$.},label={lst:simple.in}]{simple.in}

The work in this paper is focused on LAMMPS.
Although the software is well-documented\footnote{The LAMMPS documentation is known for being very detailed and precise.} and enables the user to perform advanced simulations, it can be demanding to learn how to use it well.
The core principles of molecular dynamics is so simple that high school students can easily understand the concepts, but even undergraduate students may have problems with the terminology of statistical mechanics which is used in several of the commands.
For instance, to simulate an \textit{NVE} simulation (constant number of particles $N$, volume $V$ and energy $E$), we use the \code{fix nve} command.

A LAMMPS simulation is performed by a series of commands, which are executed one by one.
LAMMPS has a huge list of implemented features which makes it very flexible, especially with its own, powerful scripting language.
In listing \ref{lst:simple.in}, we show an example of a minimalistic LAMMPS script that simulates 4000 Lennard Jones atoms in an FCC lattice with reduced temperature $T^*=1.0$ and reduced density $\rho^* = 0.8442$.
This simulation does not print much thermodynamic data, but it creates a file \code{trajectory.bin} which containes the trajectory of all atoms at every timestep.
Other programs such as VMD\citep{Humphrey1996Vmd} or OVITO\citep{Stukowski2009Visualization} can be used to visualize the file as a postprocessing step.

If we want to measure physical quantities such as energy, temperature and stress, they can be accessed through a series of commands called \textit{computes}.
For instance, the commands \code{compute ke} and \code{compute pe} measures the kinetic and the potential energy.
Using \textit{fixes}, we can create time averages and save these quantities to one or more files for plotting and further analysis.
We also often put atoms in different \textit{groups}, either by their position being in a \textit{region}, or their atom type or more advanced criteria.
Performing different operations on different groups, or just measuring physical quantities on a specific group is then easily done since almost all commands have \code{group} as an input parameter.

\begin{figure*}
	\centering
	\includegraphics[width=0.95\textwidth]{flowchart.png}
	\caption{The typical workflow when using LAMMPS consists of multiple steps using several applications.
	a) A LAMMPS script is written using a text editor.
	b) Simulation is performed from the terminal.
	c) and d) visualization and analysis is performed using Ovito and \url{http://bit.ly/logplotter}.
	Atomify simplifies the workflow by combining all steps into a single application.}
	\label{fig:flowchart}
\end{figure*}

The lack of an intuitive GUI and visualization\footnote{GUI is listed as a non-feature on the LAMMPS web page: \url{http://lammps.sandia.gov/non_features.html}.}
makes the workflow complicated, see figure \ref{fig:flowchart}.
A simulation with full analysis usually involves writing the script in a text editor, running the simulation using the terminal before analysis is done with a visualization program and additional scripts written in MATLAB or Python.
When creating a new simulation, the initial state (system box, positions of all particles, groups and regions) can be tricky to set up right, especially since groups and regions are not automatically written to the output file through the \code{dump} command.
The time from an idea to a visual feedback can then be destructive for the creativity where immediate feedback would be ideal.

We have solved this problem by creating Atomify, a real-time LAMMPS visualizer that combines script editing, simulation, visualization, and analysis in one single application.
It uses LAMMPS as a library and hooks into the LAMMPS simulation cycle so synchronization of atom positions and physical quantities can be performed as often as every timestep.
Most features of LAMMPS are automatically supported, except a few due to technical reasons discussed in section \ref{sec:future}.

The visualization is performed using the powerful Qt3D library where advanced rendering techniques such as billboard raytracing is used to achieve maximum performance.
This allows visualization of millions of atoms with good framerate on modern desktop computers.
Atomify is designed with simplicity as its main goal.

Since we have used the Qt framework to develop Atomify, and LAMMPS is written in object oriented \cpp, a simplified version is also made available on mobile platforms (Android and iOS).
This version of Atomify provides access to some of the example simulations and is intended for exploration of molecular dynamics simulations by students and scientific outreach.
It also works as a demonstration of the visualization capabilities of the desktop version of the software.
The authors are optimistic that teachers can use the visualizations provided by
Atomify to explain microscopic interactions underlying concepts in topics such
as thermodynamics, geophysics, and biology.

\begin{figure*}
	\centering
	\includegraphics[width=0.9\textwidth]{gui.png}
	\caption{%
    Overview of the Graphical User Interface (GUI) in Atomify.
    The toolbar (1) is used to change between the different modes, such as 
    editing, viewing and analyzing the running simulation, 
    in addition to playback controls.
    The file browser (2) contain the list of open LAMMPS scripts or data files.
    The text editor (3) provides code highlighting.
    The viewport (4) shows the current simulation.
    The simulation properties (5) shows the simulations details, gives access to 
    LAMMPS objects such as groups, regions and computes, and the rendering
    properties (6) lets you change the viewport settings, such as lighting and
    draw mode.
    TODO: Add numbers to figure.
    }
	\label{fig:gui}
\end{figure*}

In this paper we will go through a case study, an example simulation, where we
use many of the useful features Atomify provides.
We start by discussing the GUI in section \ref{sec:features} where the main features are summarized.
In section \ref{sec:casestudy}, the case study is introduced where we go through a typical example
of a simulation that uses regions and groups to perform different integration on different atoms.
Common pitfalls which are easily picked up with Atomify are shown.
Details about how Atomify runs LAMMPS is found in section \ref{sec:implementation} where the data flow and the threading model is explained.
Finally, we summarize the work in our paper in section \ref{sec:conclusion} with some thoughts about future outlooks in section \ref{sec:future}.

\section{\label{sec:features}Summary of features}
The main features of Atomify is summarized as script editing,
real-time visualization and plotting of physical quantities.
In addition, Atomify comes with multiple examples,
many of which have been made by members of the LAMMPS community.
It provides a lightweight script editor with syntax highlighting and line numbers.

Multiple files can be open at the same time and the state persist across working sessions.
The script can easily be restarted by clicking the button in the GUI or using
the default shortcut (\keys{Ctrl+R} in Windows and Linux or \keys{\cmd+R} in macOS).
This enables the user to get immediate visual feedback on changes in the script.

\section{\label{sec:casestudy}Case study: flow through nanoporous media}
\todo{Short motivation about flow in nanoporous media with references}
Fluid flow is often characterized with permeability, the inverse flow resistance of a material.
The permeability can be measured using Darcy's law when applying a pressure gradient.
However, the derivation of Darcy's law assume no-slip boundary conditions, i.e. the fluid velocity is zero at the boundary of a channel.
This is a good approximation for liquids in large pores, but if the channel diameter $L$ is similar or smaller than the mean free path of the fluid $\lambda$, this is no longer the case.
The Knudsen number, $\text{Kn} = \lambda / L$ quantifies this and can be used with the Klinkenberg correction to correctly describe the effective permeability as a function of pressure in the high Knudsen number limit.

\begin{figure}
	\centering
	\includegraphics[width=0.5\textwidth]{lj_flow/configuration.png}
	\caption{
		Initial configuration in our case study simulation.
		A periodic box consisting of $(40\times20\times20)$ FCC unit cells with reduced density $\rho^* = 0.8442$ where we will have gas flow in a cylinder of 5 unit cell radius.
		The different colors indicate the regions of which different integration rules apply.
		\textcolor{atomify-blue}{Blue} atoms are fixed and do not move at all,
		whereas the \textcolor{atomify-yellow}{yellow} atoms are thermalized with a Langevin\citep{schneider1978molecular} dissipative thermostat to mimick the heat exchange with the frozen bulk atoms.
		The \textcolor{atomify-red}{red} and the \textcolor{atomify-green}{green} atoms are integrated normally, except the \textcolor{atomify-green}{green} gas atoms have an applied constant acceleration representing the pressure gradient.
		Setting up and verifying this system is simple using Atomify due to the real-time coloring of groups and regions.
    }
	\label{fig:cylinder_simulation}
\end{figure}

In this case study, we will use Atomify to measure the velocity profile of a Lennard Jones gas with varying density to observe the slip velocity effect at low densities.
We will create a nanotube inside a Lennard Jones solid of size  $(40\times20\times20)$ unit cells, reduced density $\rho^* = 0.8442$, where the fluid will flow due to an induced pressure gradient, see figure \ref{fig:cylinder_simulation}.
Here we apply a pressure gradient $\nabla P$ in the $x$-direction on the gas atoms using a constant acceleration $a$ calculated as
\begin{align}
	a = \frac{\nabla P}{\rho_m},
\end{align}
where $\rho_m$ is the mass density of the gas atoms.
Applying such an acceleration means adding energy to the system which in turn will increase the temperature and eventually melt the system.
We want to couple the solid to an external heat bath so the added energy can be transferred out through a thermostat.
Even though we only apply a pressure gradient on the gas atoms, this induced momentum will also be transferred to the solid atoms which eventually will start moving in the positive $x$-direction which is not desired.
We therefore freeze the outmost atoms.
To achieve these properties of the system, the atoms are divided into multiple regions, which are integrated differently:

\begin{itemize}  
	\item $r \leq 5$: applied pressure gradient
	\item $5 < r \leq 9$: regular time integration
	\item $9 < r \leq 12$: Dissipative Langevin thermostat
	\item $12 < r$: frozen.
\end{itemize}

\subsection{Creating the initial geometry}
We create a new script in Atomify using \keys{\cmd+R}, and save it (\keys{\cmd+S}) as \code{run.in}.
Starting from the input script in listing \ref{lst:simple.in}, we modify it to create a larger simulation box with $(40\times20\times20)$ unit cells.
Then, to define the inner cylinder, we first specify the radius and the center before the region command:
\begin{lstlisting}[basicstyle=\tiny, frame = none, numbers=none, framexleftmargin=0pt, xleftmargin=-0.75cm, xrightmargin=0.0cm]
	variable R equal $(ly*0.25)
	variable c equal $(ly*0.5)
	region cylinder1 cylinder x $c $c $R EDGE EDGE
\end{lstlisting}
which gives 




\section{\label{sec:implementation}Implementation}

Atomify runs a LAMMPS instance in the background that it issues commands to.
The current state and atom positions are extracted from this instance for
visualization.
This setup makes it possible for the user to interact with LAMMPS while the
simulation is running.
Atomify is written in C++ and QML using the Qt framework.
The GUI is written in QML, while LAMMPS communication,
computations, and rendering is written in C++.
High-performance visualization is implemented as billboards in Qt3D.

\subsection{Communicating with LAMMPS}

LAMMPS can be compiled as a library with most of its contents being accessable
through either the library interface or public variables in all classes.
LAMMPS provides a C++ API that can be used to access parts of the internal data
in the simulation as well as for issuing commands to LAMMPS.
Further, direct access to raw data in LAMMPS is available through the individual
C++ classes.

\begin{figure}
	\centering
	\includegraphics[width=0.5\textwidth]{figures/data-pipeline.pdf}
	\caption{Rendering in Atomify is based on modifying the data from LAMMPS
    by coloring, producing periodic images, and generating bonds between atoms.
    The data is extracted from LAMMPS using the library API and by accessing
    the core classes.}
	\label{fig:data-pipeline}
\end{figure}

The data pipeline from LAMMPS to rendering in Atomify is illustrated in figure
\ref{fig:data-pipeline}.
When rendering one often wants to modify the data from LAMMPS before it is
visualized.
Examples are periodic images of the simulation,
slicing and coloring.
We have been inspired by the pipeline used in Ovito where the data flows through
several \textit{modifiers}, each modifying the visualization data before the
data is converted to a format for the GPU.

\subsection{Rendering techniques}

Simulations of atoms are often visualized using spheres as atoms and cylinders.
The spheres represent the atoms while the cylinders represent the bonds between
the atoms.
This way, the molecular structure is easy to understand and interpret.
In many visualization tools, the spheres and cylinders are built up by many
triangles connected so they form the geometrical object of interest.
One problem with this rendering technique is that each sphere needs many,
often hundreds, of triangles in order to look spherical.
A common technique to overcome this problem is to use billboards.

Billboards are plane objects that are always facing the camera (their normal
vector always points from the billboard center towards the camera center).
Drawing a filled circle on the billboard is a simple approximation to rendering
spheres, but this approach suffers from unrealistic distortions from the field
of view and does not make it possible to render realistic lighting.
The more robust approach, which we have chosen,
is to cast rays from the camera to the plane and calculate the sphere
intersection of each ray.
The normal vector can then be found by subtracting the intersection point from
the sphere center.

The technique of using billboards with only four vertices instead of a mesh
approximating a sphere with many more vertices is often referred to as
\emph{imposter spheres} in the literature.
% TODO add reference to literature explaining the details of rendering spheres with imposter billboards
This technique significantly reduces the number of vertices sent from the CPU to
the GPU, which in turn improves rendering performance.
A sphere may consist of an arbitrary number of vertices,
depending on the level of detail needed.
A billboard will on the other hand consist of only 4 vertices and can be
represented as a point on the CPU which is then expanded on the GPU using shader
programming.
By doing proper shading, the billboards can mimick the spheres and cylinders so
they look realistic, see Figure \ref{fig:final_billboards}.

\begin{figure}
	\centering
	\includegraphics[width=0.5\textwidth]{final_billboard.png}
	\caption{Billboards can produce pixel perfect rendering of molecules. Here we see a water molecule being rendererd with two light sources showing specular reflection and diffuse light effects.}
	\label{fig:final_billboards}
\end{figure}

\subsection{Sphere billboards}

Each sphere is visualized as two triangles making up a square large enough to
cover all pixels the sphere needs.
To reduce the CPU workload, all 4 corner vertices of the square are placed at
the exact position of the sphere.
The radius and a vertex id is specified, so that the vertex shader can move the
4 vertices so that the plane is orthogonal to the view vector and is larger than
the cross sectional area of the sphere of interest.

\subsection{Cylinder billboards}
%
% TODO should we use the other terminology here rather than billboards, something about imposter visualization?
To render bonds in the molecular structure, we have implemented a method that
visualizes realistic cylinder shapes with billboards.
Cylinders are more complicated to visualize with billboards because they have a
more complex geometry.
While spheres obviously are spherically symmetric and can be rendered the same
way regardless of viewing angle, we need to take this into account when
rendering cylinders.
Furhter, the bonds need to intersect with the sphere surface in a way that
needs to be handled by the cylinder rendering technique.

The basic principle is however the same as for the spheres.
We define the vertices needed on the CPU with the same position and add the
necessary information about the cylinder to the vertex attributes.
This information is then used in the vertex shader to draw the triangles of
the billboard.
Finally, ray tracing is used to draw the final cylinder shape based on top
of this billboard.

% TODO mention issue with end caps if this is relevant for the overlapping parts

% TODO explain the details about billboard rendering?

\section{Case study (Anders)}

% TODO Write about case study

\begin{figure}
	\centering
	\includegraphics[width=0.5\textwidth]{final_billboard.png}
	\caption{Case study result}
	\label{fig:gui}
\end{figure}

\section{\label{sec:conclusion}Conclusion}
%
We have presented Atomify, a software for live visualization of molecular
dynamics simulations in LAMMPS.
Atomify simplifies the workflow of researchers by combining script development,
analysis and visualization in an intuitive user interface.
The software can also be used to improve training of students using LAMMPS by
providing immediate, visual feedback to script changes.

The simple case study showed how Atomify can be used for quick iteration in 

\section{\label{sec:future}Future work}

Atomify continues in heavy development and we have several features planned for
future versions.
We already have a simple version of Atomify in the web browser using WebGL and WebAssembly.
This makes it easy to test scripts in the browser with all simple functionalities available.
This is especially useful in educational settings where teachers wish to introduce students
to LAMMPS without installing additional software.
It will also serve as a nice demonstration of the full desktop application of
Atomify.

Performance improvements are planned by for instance using geometry shaders in
the rendering pipeline.
This allows a fourfold reduction in the number of vertices passed from the CPU
to the GPU.
Further, geometry shaders can be used for certain modifiers,
such as the periodic copies, which are currently performed on the CPU.

% TODO Reference to KOKKOS
We also aim to include more LAMMPS backends, such as KOKKOS, and running
simulations on computing clusters while visualizing them on the users own
computers.

The script editor will get features such as autocompletion of LAMMPS commands
and easy access to the online documentation by hovering or selecting specific
commands.

We are also working on including Moltemplate and other programs that generate
systems to make it easier for users to get started with more complex
simulations.

\section{Availability}

Atomify is availabe on Linux, MacOS and Windows and can be downloaded from
\href{https://ovilab.net/atomify}{http://ovilab.net/atomify}.
A lightweight version of Atomify is also available for mobile devices running
Android or iOS.

\section{Acknowledgments}

\section{Disclosure}

Svenn-Arne Dragly is employed part-time by The Qt Company.

\bibliography{Remote}

\end{document}
